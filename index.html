<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Chronoâ€‘Chain Challenge â€” Design Championship</title>
<style>
  :root{
    --bg:#0b0f1a;--panel:#0f1626;--accent:#00f2ff;--accent2:#6df7c1;--danger:#ff3b3b;--ok:#86ff6a;--text:#e6f1ff;
  }
  html,body{height:100%;margin:0;background:radial-gradient(1200px 600px at 50% -200px,#12203a,#0b0f1a);color:var(--text);font-family:Inter,system-ui,Segoe UI,Arial,sans-serif}
  #topbar{position:fixed;inset:0 0 auto 0;height:56px;background:linear-gradient(180deg,#111a2e,#0f1626);display:flex;align-items:center;gap:14px;padding:0 16px;border-bottom:1px solid #22314f;z-index:10}
  #title{font-weight:800;letter-spacing:.4px}
  #subtitle{opacity:.8;font-size:12px}
  #wrap{display:flex;gap:12px;padding:72px 12px 12px;}
  #left{flex:1;display:flex;justify-content:center}
  #right{width:360px;max-width:36vw;background:var(--panel);border:1px solid #22314f;border-radius:16px;box-shadow:0 20px 60px rgba(0,0,0,.45);padding:12px}
  canvas{border:2px solid #22314f;border-radius:16px;box-shadow:0 10px 40px rgba(0,0,0,.45);background:#0a1020}
  .btn{display:inline-flex;align-items:center;gap:8px;padding:10px 14px;border-radius:12px;border:1px solid #28406b;background:#111a2e;color:var(--text);cursor:pointer;user-select:none}
  .btn:hover{border-color:#3a5a91;box-shadow:0 0 0 3px rgba(0,242,255,.08) inset}
  .btn.primary{background:linear-gradient(180deg,#0e2b36,#0a1f2a);border-color:#2a6a78}
  h3{margin:8px 8px 4px}
  #panel{height:520px;overflow:auto;padding:6px 8px}
  .row{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0}
  .chip{padding:6px 10px;border:1px solid #2b3f63;border-radius:999px;background:#0d1527;font-size:12px}
  .kbd{font-family:ui-monospace,SFMono-Regular,Consolas,monospace;background:#0f1b33;border:1px solid #2c3757;border-radius:6px;padding:2px 6px}
  .meter{height:8px;border-radius:999px;background:#15213c;overflow:hidden}
  .meter>span{display:block;height:100%;background:linear-gradient(90deg,var(--accent),var(--accent2));width:0%}
  #status{font-size:12px;opacity:.85}
  .tiny{font-size:11px;opacity:.75}
</style>
</head>
<body>
  <div id="topbar">
    <div>
      <div id="title">Chronoâ€‘Chain Challenge</div>
      <div id="subtitle">Chainâ€‘Reaction Puzzle â€¢ Singleâ€‘File HTML â€¢ No Libraries</div>
    </div>
    <div style="flex:1"></div>
    <div id="status">Ready</div>
  </div>
  <div id="wrap">
    <div id="left">
      <canvas id="game" width="1024" height="576"></canvas>
    </div>
    <div id="right">
      <h3>Controls</h3>
      <div id="panel">
        <div class="row">
          <div class="btn primary" id="btnPlay">â–¶ Play Sequence</div>
          <div class="btn" id="btnReset">âŸ² Reset</div>
          <div class="btn" id="btnSandbox">ðŸ§ª Sandbox</div>
          <div class="btn" id="btnStory">ðŸ“– Story</div>
        </div>
        <div class="row">
          <div class="chip">Click on grid to place or select nodes</div>
          <div class="chip">Drag to move nodes</div>
          <div class="chip">Rightâ€‘click: delete</div>
        </div>
        <h3>Palette</h3>
        <div id="palette" class="row"></div>
        <h3>Timeline</h3>
        <div class="meter"><span id="timelineFill"></span></div>
        <div class="tiny">Events visualize as the sequence runs. Parallel chains glow.</div>
        <h3>Level</h3>
        <div id="levelInfo" class="tiny">Level 1 â€¢ Score 0 â€¢ Lives 3 â€¢ Best Chain 0</div>
        <h3>Tips</h3>
        <ul class="tiny">
          <li>Build a chain from a <b>Start</b> node to the <b>Goal</b>.</li>
          <li>Use <b>Delay</b>, <b>Splitter</b>, and <b>Logic</b> nodes for complexity.</li>
          <li>Wind moves Fire; Fire melts Ice; Water grows Plant; Power activates Gate.</li>
          <li>Everything is simulated â€” experiment!</li>
        </ul>
      </div>
    </div>
  </div>
<script>
(function(){
  const W=1024,H=576,GRID=64; // 16x9 grid
  const canvas=document.getElementById('game');
  const ctx=canvas.getContext('2d');
  const statusEl=document.getElementById('status');
  const levelInfo=document.getElementById('levelInfo');
  const timelineFill=document.getElementById('timelineFill');

  // --- Utility ---
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const now=()=>performance.now();
  const rnd=(a,b)=>Math.random()*(b-a)+a;
  function snap(v){return Math.round(v/GRID)*GRID}
  function gridToWorld(gx,gy){return {x:gx*GRID+GRID/2,y:gy*GRID+GRID/2}}
  function worldToGrid(x,y){return {gx:Math.floor(x/GRID),gy:Math.floor(y/GRID)}}

  // --- Audio (tiny synth beeps) ---
  const Audio={
    ctx:null,
    init(){ if(this.ctx) return; this.ctx=new (window.AudioContext||window.webkitAudioContext)(); },
    beep(freq=440,dur=0.12,vol=0.08){ if(!this.ctx) return; const t=this.ctx.currentTime; const o=this.ctx.createOscillator(); const g=this.ctx.createGain(); o.type='sine'; o.frequency.setValueAtTime(freq,t); g.gain.setValueAtTime(vol,t); g.gain.exponentialRampToValueAtTime(0.0001,t+dur); o.connect(g).connect(this.ctx.destination); o.start(t); o.stop(t+dur); }
  };

  // --- Game State ---
  const Store={ level:1, score:0, lives:3, bestChain:0, mode:'story' };
  try{ const s=JSON.parse(localStorage.getItem('ccc-save')||'{}'); Object.assign(Store,s); }catch{}
  function persist(){ localStorage.setItem('ccc-save',JSON.stringify(Store)); }

  // --- Node Types ---
  const TYPES={
    START:{name:'Start',color:'#00f2ff'},
    GOAL:{name:'Goal',color:'#86ff6a'},
    FIRE:{name:'Fire',color:'#ff7a59'},
    ICE:{name:'Ice',color:'#7fd0ff'},
    WATER:{name:'Water',color:'#4ec3ff'},
    WIND:{name:'Wind',color:'#9be7ff'},
    PLANT:{name:'Plant',color:'#6df7c1'},
    POWER:{name:'Power',color:'#ffe66d'},
    GATE:{name:'Gate',color:'#e0ff8b'},
    DELAY:{name:'Delay',color:'#b4a5ff'},
    SPLIT:{name:'Splitter',color:'#f9a8d4'},
    AND:{name:'Logic AND',color:'#d1d5db'},
    OR:{name:'Logic OR',color:'#cbd5e1'}
  };
  const PALETTE=['START','FIRE','ICE','WATER','WIND','PLANT','POWER','GATE','DELAY','SPLIT','AND','OR','GOAL'];

  // --- Rule Engine (what triggers what) ---
  // A node receives an event {kind:"heat"|"cool"|"wet"|"push"|"power"|"signal"}
  // and can emit new events with delay.
  function nodeReact(node,ev,emit){
    switch(node.type){
      case 'START':
        if(ev.kind==='start') emit(node,'signal',0);
        break;
      case 'FIRE':
        if(ev.kind==='signal'||ev.kind==='push'){ emit(node,'heat',0); spark(node); }
        break;
      case 'ICE':
        if(ev.kind==='heat'){ emit(node,'wet',0.15); fog(node); }
        break;
      case 'WATER':
        if(ev.kind==='wet'||ev.kind==='signal'){ emit(node,'wet',0); ripple(node); }
        break;
      case 'WIND':
        if(ev.kind==='signal'){ emit(node,'push',0); gust(node); }
        break;
      case 'PLANT':
        if(ev.kind==='wet'){ emit(node,'signal',0.1); bloom(node); }
        break;
      case 'POWER':
        if(ev.kind==='signal'||ev.kind==='wet'){ emit(node,'power',0); pulse(node); }
        break;
      case 'GATE':
        if(ev.kind==='power'){ emit(node,'signal',0); shine(node); }
        break;
      case 'DELAY':
        if(ev.kind){ emit(node,ev.kind, node.delay||0.6); ping(node); }
        break;
      case 'SPLIT':
        if(ev.kind){ emit(node,ev.kind,0); emit(node,ev.kind,0.2); splitfx(node); }
        break;
      case 'AND':
        node._andHits=node._andHits||new Set();
        node._andHits.add(ev.kind);
        if(node._andHits.has('heat') && node._andHits.has('wet')){ emit(node,'signal',0); node._andHits.clear(); gatePulse(node); }
        break;
      case 'OR':
        if(ev.kind==='heat'||ev.kind==='wet'||ev.kind==='power'||ev.kind==='push'||ev.kind==='signal'){ emit(node,'signal',0); gatePulse(node); }
        break;
      case 'GOAL':
        if(ev.kind==='signal'||ev.kind==='power'){ goalGlow(node); node._goalReached=true; }
        break;
    }
  }

  // --- Particles (simple pooled system) ---
  const particles=[];
  function addParticle(x,y,clr,life=600,size=2,vx=rnd(-60,60),vy=rnd(-60,60)){
    particles.push({x,y,vx,vy,life,max:life,clr,size});
  }
  function spark(n){ for(let i=0;i<18;i++) addParticle(n.x,n.y,'#ffb199',300,2); Audio.beep(660,0.08,0.05); }
  function fog(n){ for(let i=0;i<12;i++) addParticle(n.x,n.y,'#a6d8ff',500,3,rnd(-20,20),rnd(-10,10)); Audio.beep(220,0.12,0.04); }
  function ripple(n){ for(let i=0;i<14;i++) addParticle(n.x,n.y,'#7fdbff',450,2); Audio.beep(440,0.09,0.04); }
  function gust(n){ for(let i=0;i<10;i++) addParticle(n.x,n.y,'#b3ecff',350,2,rnd(40,120),rnd(-40,40)); Audio.beep(520,0.07,0.04); }
  function bloom(n){ for(let i=0;i<10;i++) addParticle(n.x,n.y,'#8cffc1',550,3); Audio.beep(520,0.1,0.05); }
  function pulse(n){ for(let i=0;i<10;i++) addParticle(n.x,n.y,'#ffe66d',380,2); Audio.beep(700,0.07,0.05); }
  function shine(n){ for(let i=0;i<12;i++) addParticle(n.x,n.y,'#e0ff8b',420,2); Audio.beep(880,0.07,0.05); }
  function splitfx(n){ for(let i=0;i<10;i++) addParticle(n.x,n.y,'#f9a8d4',380,2); }
  function gatePulse(n){ for(let i=0;i<8;i++) addParticle(n.x,n.y,'#d1d5db',380,2); }
  function goalGlow(n){ for(let i=0;i<40;i++) addParticle(n.x,n.y,'#86ff6a',800,3); Audio.beep(1040,0.2,0.08); }

  // --- Level Data ---
  const LEVELS=[
    // Tutorial
    { name:'Forest Ruins', time:35, layout:[
      {t:'START',x:2,y:4},{t:'FIRE',x:4,y:4},{t:'ICE',x:6,y:4},{t:'WATER',x:8,y:4},{t:'PLANT',x:10,y:4},{t:'GOAL',x:13,y:4}
    ]},
    // Parallel & delays
    { name:'Windworks', time:40, layout:[
      {t:'START',x:1,y:7},{t:'WIND',x:3,y:7},{t:'FIRE',x:5,y:6},{t:'ICE',x:7,y:6},{t:'DELAY',x:7,y:8},{t:'WATER',x:9,y:7},{t:'PLANT',x:11,y:7},{t:'GOAL',x:14,y:7}
    ]},
    // Logic
    { name:'Logic Lab', time:45, layout:[
      {t:'START',x:2,y:2},{t:'FIRE',x:5,y:2},{t:'WATER',x:5,y:6},{t:'AND',x:7,y:4},{t:'POWER',x:9,y:4},{t:'GATE',x:11,y:4},{t:'GOAL',x:13,y:4}
    ]},
    // Big puzzle
    { name:'Time Rift', time:55, layout:[
      {t:'START',x:1,y:4},{t:'SPLIT',x:3,y:4},
      {t:'FIRE',x:5,y:2},{t:'ICE',x:7,y:2},{t:'WATER',x:9,y:2},{t:'PLANT',x:11,y:2},
      {t:'WIND',x:5,y:6},{t:'FIRE',x:7,y:6},{t:'DELAY',x:9,y:6},{t:'POWER',x:11,y:6},
      {t:'OR',x:13,y:4},{t:'GATE',x:15,y:4},{t:'GOAL',x:16,y:4}
    ]}
  ];

  // --- Node & Graph ---
  class Node{
    constructor(type,gx,gy){ this.type=type; this.gx=gx; this.gy=gy; const p=gridToWorld(gx,gy); this.x=p.x; this.y=p.y; this.delay=0.6; this.links=new Set(); this.id=crypto.randomUUID?.():Math.random().toString(36).slice(2); }
  }
  class Graph{
    constructor(){ this.nodes=[]; this.nodeMap=new Map(); }
    add(type,gx,gy){ const n=new Node(type,gx,gy); this.nodes.push(n); this.nodeMap.set(n.id,n); return n; }
    remove(n){ this.nodes=this.nodes.filter(x=>x!==n); this.nodes.forEach(m=>m.links.delete(n.id)); this.nodeMap.delete(n.id); }
    link(a,b){ if(a&&b&&a!==b){ a.links.add(b.id); }}
    serialize(){ return this.nodes.map(n=>({id:n.id,t:n.type,gx:n.gx,gy:n.gy,links:[...n.links]})); }
    static deserialize(data){ const g=new Graph(); const map=new Map(); data.forEach(d=>{ const n=g.add(d.t,d.gx,d.gy); n.id=d.id; map.set(d.id,n); }); g.nodes.forEach(n=>g.nodeMap.set(n.id,n)); data.forEach(d=>{ const n=map.get(d.id); d.links.forEach(id=>{ if(map.has(id)) n.links.add(id); }); }); return g; }
  }

  // --- Simulation ---
  class Simulator{
    constructor(graph){ this.g=graph; this.events=[]; this.time=0; this.running=false; this.chain=0; this.goalReached=false; }
    schedule(node,kind,delay){ this.events.push({t:this.time+delay,node,kind}); }
    start(){ this.events.length=0; this.time=0; this.running=true; this.chain=0; this.goalReached=false; // seed from START
      for(const n of this.g.nodes) if(n.type==='START') this.schedule(n,'start',0);
    }
    step(dt){ if(!this.running) return; this.time+=dt; let progressed=false; for(let i=0;i<this.events.length;i++){
        const e=this.events[i]; if(e.t<=this.time){
          progressed=true; this.events.splice(i,1); i--; // consume
          // propagate to outgoing links
          for(const id of e.node.links){ const target=this.g.nodeMap.get(id); if(!target) continue; this.chain++; nodeReact(target,{kind:e.kind},(emitter,kind,delay)=>{
            this.schedule(target,kind,delay);
          }); if(target.type==='GOAL' && (e.kind==='signal'||e.kind==='power')){ this.goalReached=true; }
          }
        }
      }
      return progressed;
    }
  }

  // --- Editor / Game Controller ---
  const State={ graph:new Graph(), selectedType:'START', selectedNode:null, dragging:false, linkFrom:null, timeLeft:30, sim:null, running:false, levelIndex:0 };

  function loadLevel(i){
    const L=LEVELS[i]; State.levelIndex=i; State.graph=new Graph(); L.layout.forEach(d=>State.graph.add(d.t,d.x,d.y)); // auto-link near neighbors (rightward)
    // simple heuristic: link to next node horizontally to the right if within same row band
    const rowMap={};
    State.graph.nodes.forEach(n=>{ rowMap[n.gy]=rowMap[n.gy]||[]; rowMap[n.gy].push(n); });
    Object.values(rowMap).forEach(arr=>{ arr.sort((a,b)=>a.gx-b.gx); for(let k=0;k<arr.length-1;k++){ State.graph.link(arr[k],arr[k+1]); } });
    State.timeLeft=L.time; State.running=false; State.sim=new Simulator(State.graph);
    updateHud(); setStatus(`Loaded level ${i+1}: ${L.name}`);
  }

  function updateHud(){ levelInfo.textContent=`Level ${State.levelIndex+1}/${LEVELS.length} â€¢ Score ${Store.score} â€¢ Lives ${Store.lives} â€¢ Best Chain ${Store.bestChain}`; }
  function setStatus(t){ statusEl.textContent=t; }

  // --- Drawing ---
  function drawGrid(){ ctx.strokeStyle='#1a2746'; ctx.lineWidth=1; for(let x=0;x<=W;x+=GRID){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); } for(let y=0;y<=H;y+=GRID){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); } }
  function drawLink(a,b,glow=false){ const g=ctx.createLinearGradient(a.x,a.y,b.x,b.y); g.addColorStop(0,'#00f2ff'); g.addColorStop(1,'#6df7c1'); ctx.strokeStyle=g; ctx.lineWidth= glow?4:2; ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke(); }
  function drawNode(n,highlight=false){ const col=TYPES[n.type].color; ctx.save(); ctx.translate(n.x,n.y); if(highlight) ctx.shadowColor=col,ctx.shadowBlur=18; ctx.fillStyle=col; ctx.beginPath(); ctx.arc(0,0,20,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#0b0f1a'; ctx.font='700 11px ui-monospace,monospace'; ctx.textAlign='center'; ctx.fillText(n.type,0,4); ctx.restore(); }
  function drawParticles(dt){ for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.life-=dt*1000; if(p.life<=0){ particles.splice(i,1); continue; } p.x+=p.vx*dt; p.y+=p.vy*dt; ctx.globalAlpha=p.life/p.max; ctx.fillStyle=p.clr; ctx.fillRect(p.x,p.y,p.size,p.size); ctx.globalAlpha=1; } }

  // --- Input ---
  let mouse={x:0,y:0,down:false,rx:0,ry:0};
  canvas.addEventListener('mousemove',e=>{ const r=canvas.getBoundingClientRect(); mouse.x=(e.clientX-r.left)*canvas.width/r.width; mouse.y=(e.clientY-r.top)*canvas.height/r.height; });
  canvas.addEventListener('mousedown',e=>{ Audio.init(); mouse.down=true; if(e.button===2){ // delete
      const n=pickNode(mouse.x,mouse.y); if(n){ State.graph.remove(n); setStatus('Deleted node'); }
      return;
    }
    const n=pickNode(mouse.x,mouse.y); if(n){ State.selectedNode=n; State.dragging=true; setStatus(`Selected ${n.type}`); if(e.shiftKey){ State.linkFrom=n; }
    }else{ // place new
      const {gx,gy}=worldToGrid(mouse.x,mouse.y); const type=State.selectedType; const m=State.graph.add(type,gx,gy); State.selectedNode=m; State.dragging=true; setStatus(`Placed ${type}`); }
  });
  canvas.addEventListener('mouseup',e=>{ mouse.down=false; State.dragging=false; if(State.linkFrom){ const t=pickNode(mouse.x,mouse.y); if(t && t!==State.linkFrom){ State.graph.link(State.linkFrom,t); setStatus(`Linked ${State.linkFrom.type} â†’ ${t.type}`); } State.linkFrom=null; }
  });
  canvas.addEventListener('contextmenu',e=>e.preventDefault());

  function pickNode(x,y){ for(const n of State.graph.nodes){ if((x-n.x)**2+(y-n.y)**2<22*22) return n; } return null; }

  // --- Palette UI ---
  const pal=document.getElementById('palette');
  PALETTE.forEach(key=>{
    const b=document.createElement('div'); b.className='btn'; b.style.borderColor='#2b3f63'; b.style.background='#0f1b33'; b.textContent=TYPES[key].name; b.style.boxShadow=`0 0 0 3px rgba(0,0,0,0) inset`; b.addEventListener('click',()=>{ State.selectedType=key; [...pal.children].forEach(c=>c.style.boxShadow='none'); b.style.boxShadow='0 0 0 2px rgba(0,242,255,.35) inset'; setStatus(`Selected tool: ${key}`); }); pal.appendChild(b); if(key==='START') b.click();
  });

  // --- Buttons ---
  document.getElementById('btnPlay').onclick=()=>{ if(State.running) return; State.sim=new Simulator(State.graph); State.sim.start(); State.running=true; setStatus('Runningâ€¦'); };
  document.getElementById('btnReset').onclick=()=>{ State.running=false; State.sim=new Simulator(State.graph); timelineFill.style.width='0%'; setStatus('Reset'); };
  document.getElementById('btnSandbox').onclick=()=>{ Store.mode='sandbox'; persist(); setStatus('Sandbox mode â€” build freely'); };
  document.getElementById('btnStory').onclick=()=>{ Store.mode='story'; persist(); loadLevel(State.levelIndex); };

  // --- Game Loop ---
  let last=now();
  function tick(){ const t=now(); const dt=(t-last)/1000; last=t; ctx.clearRect(0,0,W,H); drawGrid();
    // dragging
    if(State.dragging && State.selectedNode){ const {gx,gy}=worldToGrid(mouse.x,mouse.y); State.selectedNode.gx=clamp(gx,0,Math.floor(W/GRID)-1); State.selectedNode.gy=clamp(gy,0,Math.floor(H/GRID)-1); const p=gridToWorld(State.selectedNode.gx,State.selectedNode.gy); State.selectedNode.x=p.x; State.selectedNode.y=p.y; }
    // links
    for(const a of State.graph.nodes){ for(const id of a.links){ const b=State.graph.nodeMap.get(id); if(b) drawLink(a,b,State.running); } }
    // nodes
    for(const n of State.graph.nodes){ drawNode(n, State.running && (n.type==='START' || n.type==='GOAL')); }
    // particles
    drawParticles(dt);

    // simulation
    if(State.running){ const progressed=State.sim.step(dt); const dur=LEVELS[State.levelIndex]?.time||40; timelineFill.style.width=clamp((State.sim.time/dur)*100,0,100)+"%"; if(progressed) Store.score+=1;
      if(State.sim.goalReached){ // win level
        Store.score+=250; Store.bestChain=Math.max(Store.bestChain,State.sim.chain); State.running=false; setStatus('Goal reached! Level complete.'); nextLevel(); persist(); }
      if(State.sim.time> (LEVELS[State.levelIndex]?.time||40)){
        State.running=false; Store.lives--; setStatus('Time up!'); if(Store.lives<0){ gameOver(); } persist();
      }
    }

    requestAnimationFrame(tick);
  }

  function nextLevel(){ if(Store.mode==='sandbox') return; if(State.levelIndex<LEVELS.length-1){ State.levelIndex++; loadLevel(State.levelIndex); } else { setStatus('You completed all story levels! Try Sandbox.'); }
    updateHud(); }
  function gameOver(){ setStatus('Game Over â€” refresh to restart'); }

  // --- Boot ---
  if(Store.mode==='story'){ loadLevel(State.levelIndex); } else { State.graph=new Graph(); State.sim=new Simulator(State.graph); setStatus('Sandbox mode â€” build your own!'); }
  updateHud();
  tick();
})();
</script>
</body>
</html>

